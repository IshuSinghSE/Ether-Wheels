{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "contracts/CarPooling.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.24;\r\n\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\nimport \"./PriceConverter.sol\";\r\n\r\n// Create ride\r\n// book ride\r\n// withdraw money for ride\r\n// cancel ride :- driver(return all money back to passengers), passenger(return deducted amount back to passenger)\r\n// get all ride :- either make an array to save keys in contract itself or use getALL for the first time to get all the keys then maintain them in the frontend\r\n// get index function :- to remove repeated code for getting the index\r\n\r\n// Tests\r\n// create a ride\r\n// get all rides, single ride and user rides\r\n// book a ride\r\n// mark completion status by passenger\r\n// cancel by passenger and by driver\r\n// withdraw money via driver\r\n\r\n// Things that can be implemented in this contract\r\n// 1. Fallback functions  --> not needed\r\n// 2. Time based cancellation refund system \r\n// 3. Events -> added \r\n// 4. Writing tests (just in case if you feel like)\r\n\r\nerror ERROR_CarPooling(string message);\r\n\r\ncontract CarPooling {\r\n    using PriceConverter for uint256;\r\n\r\n    AggregatorV3Interface public s_priceFeed;\r\n\r\n    constructor(address priceFeedAddress) {\r\n        s_priceFeed = AggregatorV3Interface(priceFeedAddress);\r\n    }\r\n\r\n    event RideCreated(\r\n        uint256 indexed rideId,\r\n        address driver,\r\n        uint256 maxPassengers,\r\n        uint256 rideFare,\r\n        uint256 time,\r\n        string tripDetails\r\n    );\r\n    event RideBooked(uint256 indexed rideId, address[] passengers);\r\n    event StatusUpdate(uint256 indexed rideId, uint256 completedStatus);\r\n\r\n    struct Ride {\r\n        address driver; // time // locations (source and destination)\r\n        address[] passengers;\r\n        uint256 maxPassengers;\r\n        uint256 rideFare; // co ordinates des co ordinates save -- passenger ride filter\r\n        uint256 rideId;\r\n        uint256 time; // startTime\r\n        string tripDetails; // source and des\r\n    }\r\n\r\n    mapping(uint256 => Ride) public rides;\r\n    mapping(address => uint256[]) public addressToRides;\r\n    mapping(uint256 => uint256) public completionStatus;\r\n\r\n    uint256 public rideCount = 0;\r\n    uint256[] public rideKeys; // delete when ride is cancelled\r\n\r\n    function createRide(\r\n        uint256 mp,\r\n        uint256 rf,\r\n        uint256 t,\r\n        string memory td\r\n    ) public {\r\n        rideCount += 1;\r\n        uint256 rid = rideCount;\r\n        address[] memory p;\r\n        rf = rf * 1e18;\r\n        rf = rf.getPriceInEth(s_priceFeed);\r\n        rides[rid] = Ride(msg.sender, p, mp, rf, rid, t, td);\r\n\r\n        addressToRides[msg.sender].push(rid);\r\n        completionStatus[rid] = 0;\r\n        rideKeys.push(rid);\r\n\r\n        emit RideCreated(rid, msg.sender, mp, rf, t, td);\r\n    }\r\n\r\n    function bookRide(uint256 rideId) public payable duplicate(rideId) {\r\n        if (msg.value < rides[rideId].rideFare)\r\n            revert ERROR_CarPooling({\r\n                message: \"Money sent not equal to ride Fare\"\r\n            });\r\n        rides[rideId].passengers.push(msg.sender);\r\n        addressToRides[msg.sender].push(rideId);\r\n\r\n        emit RideBooked(rideId, rides[rideId].passengers);\r\n    }\r\n\r\n    modifier duplicate(uint256 rideId) {\r\n        Ride memory r = rides[rideId];\r\n        if (msg.sender == r.driver || r.passengers.length == r.maxPassengers) {\r\n            revert ERROR_CarPooling({\r\n                message: \"Driver cannot book the ride or maximum passengers reached\"\r\n            });\r\n        }\r\n        for (uint256 i = 0; i < r.passengers.length; i++) {\r\n            if (msg.sender == r.passengers[i]) {\r\n                revert ERROR_CarPooling({\r\n                    message: \"You have already booked the ride\"\r\n                });\r\n            }\r\n        }\r\n        _;\r\n    }\r\n\r\n    function updateStatus(uint256 rideId) public {\r\n        // completion of ride by passengers\r\n        address passenger = msg.sender;\r\n        uint256[] memory pRides = addressToRides[passenger];\r\n        (bool exists, uint256 index) = getIndex(pRides, rideId);\r\n\r\n        if (!exists) {\r\n            revert ERROR_CarPooling({\r\n                message: \"Ride is not registered with passenger\"\r\n            });\r\n        }\r\n\r\n        completionStatus[rideId] += 1;\r\n\r\n        // erase this ride from passengers list\r\n        addressToRides[passenger][index] = pRides[pRides.length - 1];\r\n        addressToRides[passenger].pop();\r\n\r\n        emit StatusUpdate(rideId, completionStatus[rideId]);\r\n    }\r\n\r\n    function rideCompleted(uint256 rideId) public {\r\n        // driver withdrawing money\r\n        if (msg.sender != rides[rideId].driver) {\r\n            revert ERROR_CarPooling({message: \"Sender is not the driver\"});\r\n        }\r\n        if (completionStatus[rideId] != rides[rideId].passengers.length) {\r\n            revert ERROR_CarPooling({\r\n                message: \"Not all passengers have marked the ride as completed\"\r\n            });\r\n        }\r\n\r\n        uint256 count = rides[rideId].passengers.length;\r\n        uint256 amount = count * rides[rideId].rideFare;\r\n\r\n        (bool callSuccess, ) = payable(msg.sender).call{value: amount}(\"\");\r\n        require(callSuccess, \"Call method failed\");\r\n\r\n        // erase ride from drivers list erase completion status for this ride id\r\n        completionStatus[rideId] = 0;\r\n        uint256[] memory driverRides = addressToRides[msg.sender];\r\n        (bool exists, uint256 index) = getIndex(driverRides, rideId);\r\n\r\n        if (!exists) {\r\n            revert ERROR_CarPooling({\r\n                message: \"Ride is not registerd with driver\"\r\n            });\r\n        }\r\n\r\n        addressToRides[msg.sender][index] = driverRides[driverRides.length - 1];\r\n        addressToRides[msg.sender].pop();\r\n\r\n        // erase ride from rides mapping as ride is completed\r\n        rides[rideId] = rides[0]; // rides[0] is never given anything so will put default values back in rideId\r\n\r\n        // erase rideId from rideKeys\r\n        uint256[] memory keys = rideKeys;\r\n        (exists, index) = getIndex(keys, rideId);\r\n\r\n        if (!exists) {\r\n            revert ERROR_CarPooling({message: \"Key does not exist\"});\r\n        }\r\n\r\n        rideKeys[index] = keys[keys.length - 1];\r\n        rideKeys.pop();\r\n    }\r\n\r\n    function cancelRide(uint256 rideId) public {\r\n        // two cases\r\n        // 1. Either cancelled by the driver\r\n        // 2. Or cancelled by one of the passegners\r\n\r\n        Ride memory r = rides[rideId];\r\n        if (msg.sender == r.driver) {\r\n            // return full money back to all passengers\r\n            address[] memory passengers = r.passengers;\r\n            uint256 amount = r.rideFare;\r\n\r\n            for (uint256 i = 0; i < passengers.length; i++) {\r\n                address p = passengers[i];\r\n                (bool callSuccess, ) = payable(p).call{value: amount}(\"\");\r\n                require(callSuccess, \"Call method failed\");\r\n            }\r\n\r\n            // remove ride from driver's list\r\n            uint256[] memory driverRides = addressToRides[msg.sender];\r\n            (bool exists, uint256 index) = getIndex(driverRides, rideId);\r\n\r\n            if (!exists) {\r\n                revert ERROR_CarPooling(\"Ride is not registered with the user\");\r\n            }\r\n\r\n            addressToRides[msg.sender][index] = driverRides[\r\n                driverRides.length - 1\r\n            ];\r\n            addressToRides[msg.sender].pop();\r\n\r\n            // remove ride from rides mapping as well as the ride is deleted\r\n            rides[rideId] = rides[0];\r\n\r\n            // remove the rideId from ride keys\r\n            uint256[] memory keys = rideKeys;\r\n            (exists, index) = getIndex(keys, rideId);\r\n\r\n            if (!exists) {\r\n                revert ERROR_CarPooling(\"Key does not exist\");\r\n            }\r\n\r\n            rideKeys[index] = keys[keys.length - 1];\r\n            rideKeys.pop();\r\n\r\n            // reset the completion status\r\n            completionStatus[rideId] = 0;\r\n        } else {\r\n            // passenger cancels\r\n            // erase address from rides passenger array\r\n            uint256 index;\r\n            address passenger = msg.sender;\r\n            address[] memory passengers = r.passengers;\r\n            for (uint256 i = 0; i < passengers.length; i++) {\r\n                if (passengers[i] == passenger) {\r\n                    index = i;\r\n                    break;\r\n                }\r\n            }\r\n            rides[rideId].passengers[index] = passengers[passengers.length - 1];\r\n            rides[rideId].passengers.pop();\r\n\r\n            // erases ride from passengers rides list\r\n            bool exists;\r\n            uint256[] memory userRides = addressToRides[passenger];\r\n            (exists, index) = getIndex(userRides, rideId);\r\n            if (!exists) {\r\n                revert ERROR_CarPooling(\"Ride is not registered with user\");\r\n            }\r\n            addressToRides[msg.sender][index] = userRides[userRides.length - 1];\r\n            addressToRides[msg.sender].pop();\r\n\r\n            // return half of the money back to passenger  ( can make it time based in future)\r\n            uint256 amount = r.rideFare;\r\n            amount = amount / 2;\r\n\r\n            (bool callSuccess1, ) = payable(passenger).call{value: amount}(\"\");\r\n            require(callSuccess1, \"Call method failed\");\r\n\r\n            // compensate the driver with some money, half of ride fare as of now (fixed amount or maybe some time based amount for him as well)\r\n            (bool callSuccess2, ) = payable(r.driver).call{value: amount}(\"\");\r\n            require(callSuccess2, \"Call method failed\");\r\n        }\r\n    }\r\n\r\n    function getIndex(\r\n        uint256[] memory array,\r\n        uint256 val\r\n    ) public pure returns (bool, uint256) {\r\n        uint256 index = 0;\r\n        bool exists = false;\r\n        for (uint256 i = 0; i < array.length; i++) {\r\n            if (array[i] == val) {\r\n                index = i;\r\n                exists = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return (exists, index);\r\n    }\r\n\r\n    function getRide(\r\n        uint256 rideId\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            address,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            string memory\r\n        )\r\n    {\r\n        Ride memory r = rides[rideId];\r\n        return (\r\n            r.driver,\r\n            r.passengers.length,\r\n            r.maxPassengers,\r\n            r.rideFare,\r\n            r.rideId,\r\n            r.time,\r\n            r.tripDetails\r\n        );\r\n    }\r\n\r\n    function getUserRides()\r\n        public\r\n        view\r\n        returns (\r\n            address[] memory,\r\n            uint256[] memory,\r\n            uint256[] memory,\r\n            uint256[] memory,\r\n            uint256[] memory,\r\n            uint256[] memory,\r\n            string[] memory\r\n        )\r\n    {\r\n        uint256[] memory userRides = addressToRides[msg.sender];\r\n\r\n        address[] memory drivers = new address[](userRides.length);\r\n        uint256[] memory currentPassengers = new uint256[](userRides.length);\r\n        uint256[] memory maxPassengers = new uint256[](userRides.length);\r\n        uint256[] memory rideFare = new uint256[](userRides.length);\r\n        uint256[] memory rideId = new uint256[](userRides.length);\r\n        uint256[] memory time = new uint256[](userRides.length);\r\n        string[] memory td = new string[](userRides.length);\r\n\r\n        for (uint256 i = 0; i < userRides.length; i++) {\r\n            Ride memory r = rides[userRides[i]]; // CHECK IF RIDE EXISTS FOR GIVEN ID OR NOT\r\n            if (r.rideId != 0) {\r\n                drivers[i] = r.driver;\r\n                currentPassengers[i] = r.passengers.length;\r\n                maxPassengers[i] = r.maxPassengers;\r\n                rideFare[i] = r.rideFare;\r\n                rideId[i] = r.rideId;\r\n                time[i] = r.time;\r\n                td[i] = r.tripDetails;\r\n            }\r\n        }\r\n\r\n        return (\r\n            drivers,\r\n            currentPassengers,\r\n            maxPassengers,\r\n            rideFare,\r\n            rideId,\r\n            time,\r\n            td\r\n        ); // cd not sent coz stack too deep error find a fix\r\n    }\r\n\r\n    function getAllRides()\r\n        public\r\n        view\r\n        returns (\r\n            address[] memory,\r\n            uint256[] memory,\r\n            uint256[] memory,\r\n            uint256[] memory,\r\n            uint256[] memory,\r\n            uint256[] memory,\r\n            string[] memory\r\n        )\r\n    {\r\n        uint256[] memory keys = rideKeys;\r\n\r\n        address[] memory drivers = new address[](keys.length);\r\n        uint256[] memory currentPassengers = new uint256[](keys.length);\r\n        uint256[] memory maxPassengers = new uint256[](keys.length);\r\n        uint256[] memory rideFare = new uint256[](keys.length);\r\n        uint256[] memory rideId = new uint256[](keys.length);\r\n        uint256[] memory time = new uint256[](keys.length);\r\n        string[] memory td = new string[](keys.length);\r\n\r\n        for (uint256 i = 0; i < keys.length; i++) {\r\n            Ride memory r = rides[keys[i]]; // CHECK IF RIDE EXISTS FOR GIVEN ID OR NOT\r\n            if (r.rideId != 0) {\r\n                drivers[i] = r.driver;\r\n                currentPassengers[i] = r.passengers.length;\r\n                maxPassengers[i] = r.maxPassengers;\r\n                rideFare[i] = r.rideFare;\r\n                rideId[i] = r.rideId;\r\n                time[i] = r.time;\r\n                td[i] = r.tripDetails;\r\n            }\r\n        }\r\n\r\n        return (\r\n            drivers,\r\n            currentPassengers,\r\n            maxPassengers,\r\n            rideFare,\r\n            rideId,\r\n            time,\r\n            td\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/PriceConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\n\r\n// Why is this a library and not abstract?\r\n// Why not an interface?\r\nlibrary PriceConverter {\r\n    // We could make this public, but then we'd have to deploy it\r\n    function getPrice(\r\n        AggregatorV3Interface priceFeed\r\n    ) internal view returns (uint256) {\r\n        (, int256 answer, , , ) = priceFeed.latestRoundData();\r\n        // ETH/USD rate in 18 digit\r\n        return uint256(answer * 10000000000);\r\n        // or (Both will do the same thing)\r\n        // return uint256(answer * 1e10); // 1* 10 ** 10 == 10000000000\r\n    }\r\n\r\n    // 1000000000\r\n    function getConversionRate(\r\n        uint256 ethAmount,\r\n        AggregatorV3Interface priceFeed\r\n    ) internal view returns (uint256) {\r\n        uint256 ethPrice = getPrice(priceFeed);\r\n        uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1000000000000000000;\r\n        // or (Both will do the same thing)\r\n        // uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1e18; // 1 * 10 ** 18 == 1000000000000000000\r\n        // the actual ETH/USD conversion rate, after adjusting the extra 0s.\r\n        return ethAmountInUsd;\r\n    }\r\n\r\n    function getPriceInEth(\r\n        uint256 dollarAmount,\r\n        AggregatorV3Interface priceFeed\r\n    ) internal view returns (uint256) {\r\n        uint256 ethPrice = getPrice(priceFeed);\r\n\r\n        uint256 usdInEth = (dollarAmount * 1e18) / ethPrice;\r\n\r\n        return usdInEth;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}